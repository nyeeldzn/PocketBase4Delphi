unit Model.Store.BaseAuthStore;

interface

uses
  System.SysUtils,
  System.JSON,
  REST.JSON,
  System.Generics.Collections,
  Model.Stores.Utils.Jwt,
  model.Stores.Utils.Cookie;

const
  DEFAULT_COOCKIE_KEY = 'pb_auth';

implementation

type
  AuthModel = TJSONPair;

  OnStoreChangeFunction = reference to
    procedure(AToken: string; AModel: AuthModel);

  BaseAuthStore = class abstract
  protected
    FBaseToken: string;
    FBaseModel: AuthModel;
  private
    FOnChangeCallbacks: TList<OnStoreChangeFunction>;
    procedure triggerChange();
    function onChange(ACallback: OnStoreChangeFunction; AFireImmediately: boolean = False): TProc;
  public
    property Token: string read FBaseToken;
    property Model: AuthModel read FBaseModel;

    function IsValid(): boolean;
    function IsAdmin(): boolean;
    function IsAuthRecord(): boolean;

    procedure LoadFromCookie(cookie: string; Key: string = DEFAULT_COOCKIE_KEY);
    function ExportToCookie(options: TSerializeOptions = nil; const key: string = defaultCookieKey): string;

    procedure Save(AToken: string; AModel: AuthModel);
    procedure Clear();
  end;

  { BaseAuthStore }

function BaseAuthStore.IsAdmin: boolean;
begin
  Result := TJWTUtils.getTokenPayload(self.Token).GetValue('type').ToString = 'admin';
end;

function BaseAuthStore.IsAuthRecord: boolean;
begin
  Result := TJWTUtils.getTokenPayload(self.Token).GetValue('type').ToString = 'authRecord';
end;

function BaseAuthStore.IsValid: boolean;
begin
  Result := not TJWTUtils.IsTokenExpired(self.Token)
end;

procedure BaseAuthStore.LoadFromCookie(cookie, Key: string);
var
  jsonObject: TJSONObject;
  rawData   : string;
  data      : TJSONObject;
  Token     : string;
  Model     : TJSONValue;
begin
  jsonObject := TJSONObject.Create;
  data       := TJSONObject.Create;

  try
    jsonObject := TJSONObject.ParseJSONValue(cookie) as TJSONObject;
    if Assigned(jsonObject) then
    begin
      rawData := jsonObject.GetValue(Key).Value;

      try
        data := TJSONObject.ParseJSONValue(rawData) as TJSONObject;
      except
        on E: EJSONException do
        begin
          Exit;
        end;
      end;

      // Normalização
      if
        not Assigned(data) or
        not(data is TJSONObject)
      then
      begin
        data.Free;
        data := TJSONObject.Create;
      end;

      // Obter os valores token e model
      Token := data.GetValue('token').Value;
      // Model := data.GetValue('model');

      // Chamada para função Save
      Save(Token, AuthModel.Create('', ''));
    end;
  finally
    jsonObject.Free;
    data.Free;
  end;

end;


function BaseAuthStore.ExportToCookie(options: TSerializeOptions = nil; const key: string = defaultCookieKey): string;
var
  DefaultOptions: TSerializeOptions;
  Payload: TJSONObject;
  RawData: TJSONObject;
  ResultData: string;
  ResultLength: Integer;
  Prop: string;
  ExtraProps: TArray<string>;
begin
  // Definição das opções padrão para serialização do cookie
  DefaultOptions := TSerializeOptions.Create;
  DefaultOptions.Secure := True;
  DefaultOptions.SameSite := True;
  DefaultOptions.HttpOnly := True;
  DefaultOptions.Path := '/';

  // Extração da data de expiração do token, se existir
  Payload := GetTokenPayload(self.token);
  if Assigned(Payload) and (Payload.GetValue('exp') <> nil) then
    DefaultOptions.Expires := EncodeDate(1970, 1, 1) + (Payload.GetValue('exp').AsInt64 * OneSecond)
  else
    DefaultOptions.Expires := EncodeDate(1970, 1, 1);

  // Fusão das opções padrão com as opções do usuário, se existirem
  if Assigned(options) then
    MergeSerializeOptions(DefaultOptions, options);

  // Criação do objeto JSON com os dados a serem serializados
  RawData := TJSONObject.Create;
  try
    RawData.AddPair('token', self.token);

    // Verificação e serialização do modelo, se existir
    if Assigned(self.model) then
    begin
      // Simplificação do modelo para um conjunto mínimo de propriedades
      RawData.AddPair('model', self.model.Simplify);

      // Adição de propriedades adicionais específicas
      ExtraProps := TArray<string>.Create('collectionId', 'username', 'verified');
      for Prop in self.model.Properties do
        if ExtraProps.Contains(Prop) then
          RawData.GetValue('model').AsType<TJSONObject>.AddPair(Prop, self.model.GetValue(Prop));
    end
    else
      RawData.AddPair('model', TJSONNull.Create);

    // Serialização do objeto JSON em string
    ResultData := TJSONUtils.ToJSON(RawData);

    // Verificação do tamanho da string serializada para tomada de decisão
    ResultLength := Length(ResultData);
    if ResultLength > 4096 then
    begin
      // Redução do modelo para tamanho menor, se exceder um limite
      // ... (lógica de redução)
      ResultData := TJSONUtils.ToJSON(RawData); // Serialização final com modelo reduzido
    end;

    // Resultado final da serialização
    Result := CookieSerialize(key, ResultData, DefaultOptions);

  finally
    RawData.Free;
  end;
end;

function BaseAuthStore.onChange(ACallback: OnStoreChangeFunction;
  AFireImmediately: boolean): TProc;
begin
  FOnChangeCallbacks.Add(ACallback);

  if
    AFireImmediately
  then
    ACallback(self.Token, self.Model);

  Result := procedure
    begin
      FOnChangeCallbacks.Remove(ACallback);
    end;
end;

procedure BaseAuthStore.triggerChange;
begin
  if
    Assigned(FOnChangeCallbacks)
  then
  begin
    for var callback in FOnChangeCallbacks do
    begin
      callback(self.Token, self.Model)
    end;
  end;
end;

procedure BaseAuthStore.Save(AToken: string; AModel: AuthModel);
begin
  FBaseToken := AToken;
  FBaseModel := AModel;

  triggerChange();
end;

procedure BaseAuthStore.Clear;
begin
  FBaseToken := '';
  FBaseModel := nil;

  triggerChange();
end;

end.
