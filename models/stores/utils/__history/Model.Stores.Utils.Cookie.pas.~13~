unit Model.Stores.Utils.Cookie;

interface

uses
  System.SysUtils,
  System.NetEncoding,
  System.Generics.Collections;

type
  TDecodeFunction = function(const Val: string): string;

  TSerializeOptions = record
    Encode: function(Val: string; Num: Integer; Bool: Boolean): string;
    MaxAge: Integer;
    Domain: string;
    Path: string;
    Expires: TDateTime;
    HttpOnly: Boolean;
    Secure: Boolean;
    Priority: string;
    SameSite: Boolean or string;
  end;

  TParseOptions = class
  private
    FDecode: TDecodeFunction;
  public
    property Decode: TDecodeFunction read FDecode write FDecode;
  end;

function CookieParse(const Str: string; Options: TParseOptions = nil): TDictionary<string, string>;
function DefaultDecode(const Val: string): string;

implementation

function CookieParse(const Str: string; Options: TParseOptions = nil): TDictionary<string, string>;
var
  ResultDict          : TDictionary<string, string>;
  Opt                 : TParseOptions;
  DecodeFunc          : TDecodeFunction;
  Index, EqIdx, EndIdx: Integer;
  Key, Val            : string;
begin
  ResultDict := TDictionary<string, string>.Create;

  if Str = '' then
    Exit(ResultDict);

  Opt        := TParseOptions.Create;
  Opt.Decode := DefaultDecode;
  //
  // if
  // Assigned(Options)
  // then
  // MergeParseOptions(Opt, Options);

  DecodeFunc := Opt.Decode;

  Index := 1;
  while Index <= Length(Str) do
  begin
    EqIdx := Pos('=', Str, Index);

    // No more cookie pairs
    if
      EqIdx = 0
    then
      Break;

    EndIdx := Pos(';', Str, Index);

    if
      EndIdx = 0
    then
      EndIdx := Length(Str) + 1
    else
      if
      EndIdx < EqIdx
    then
    begin
      Index := LastDelimiter(';', Copy(Str, 1, EqIdx - 1)) + 1;
      Continue;
    end;

    Key := Trim(Copy(Str, Index, EqIdx - Index));

    // Only assign once
    if
      not ResultDict.ContainsKey(Key)
    then
    begin
      Val := Trim(Copy(Str, EqIdx + 1, EndIdx - EqIdx - 1));

      // Quoted values
      if
        Ord(Val[1]) = $22
      then
        Val := Copy(Val, 2, Length(Val) - 2);

      try
        ResultDict.Add(Key, DecodeFunc(Val));
      except
        ResultDict.Add(Key, Val); // No decoding
      end;
    end;

    Index := EndIdx + 1;
  end;

  Result := ResultDict;
end;

function CookieSerialize(name, val: string; options: TSerializeOptions): string;
var
  optEncode: function(Val: string; Num: Integer; Bool: Boolean): string;
  maxAge: Integer;
  priority, sameSite: string;
begin
  if not RegEx.IsMatch(name, fieldContentRegExp) then
    raise Exception.Create('argument name is invalid');

  optEncode := options.Encode;
  if not Assigned(optEncode) then
    optEncode := DefaultEncode;

  val := optEncode(val);

  if (val <> '') and (not RegEx.IsMatch(val, fieldContentRegExp)) then
    raise Exception.Create('argument val is invalid');

  Result := name + '=' + val;

  maxAge := options.MaxAge;
  if maxAge <> 0 then
  begin
    if (maxAge <> 0) and (not IsFinite(maxAge)) then
      raise Exception.Create('option maxAge is invalid');

    Result := Result + '; Max-Age=' + IntToStr(Trunc(maxAge));
  end;

  if options.Domain <> '' then
  begin
    if not RegEx.IsMatch(options.Domain, fieldContentRegExp) then
      raise Exception.Create('option domain is invalid');

    Result := Result + '; Domain=' + options.Domain;
  end;

  if options.Path <> '' then
  begin
    if not RegEx.IsMatch(options.Path, fieldContentRegExp) then
      raise Exception.Create('option path is invalid');

    Result := Result + '; Path=' + options.Path;
  end;

  if options.Expires <> 0 then
  begin
    if options.Expires = 0 then
      raise Exception.Create('option expires is invalid');

    Result := Result + '; Expires=' + FormatDateTime('ddd, dd mmm yyyy hh:nn:ss "GMT"', options.Expires);
  end;

  if options.HttpOnly then
    Result := Result + '; HttpOnly';

  if options.Secure then
    Result := Result + '; Secure';

  priority := LowerCase(options.Priority);
  if priority <> '' then
  begin
    case priority of
      'low': Result := Result + '; Priority=Low';
      'medium': Result := Result + '; Priority=Medium';
      'high': Result := Result + '; Priority=High';
    else
      raise Exception.Create('option priority is invalid');
    end;
  end;

  sameSite := LowerCase(options.SameSite);
  if sameSite <> '' then
  begin
    case sameSite of
      'true': Result := Result + '; SameSite=Strict';
      'lax': Result := Result + '; SameSite=Lax';
      'strict': Result := Result + '; SameSite=Strict';
      'none': Result := Result + '; SameSite=None';
    else
      raise Exception.Create('option sameSite is invalid');
    end;
  end;
end;

function DefaultDecode(const Val: string): string;
begin
  if
    Pos('%', Val) <> 0
  then
    Result := TNetEncoding.URL.Decode(Val)
  else
    Result := Val;
end;

end.
